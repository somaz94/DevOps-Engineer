### 1. 웹 브라우저의 동작원리

1. 사용자가 브라우저로 웹 사이트에 접속(e.g., www.example.com)
2. DNS를 통해 서버의 아이피 주소를 파악
3. 브라우저와 서버가 3 Way Handshake
4. 브라우저가 서버에게 HTTP Request(서버에게 데이터 요청)
5. 브라우저가 서버로부터 HTTP Response(서버로부터 데이터를 받음)
6. 서버로부터 받은 데이터에 HTML 파싱하여 Dom Tree 생성
7. Style 태그를 만나면 Dom 생성을 잠깐 중지하고 CSS를 파싱하여 CSSOM Tree 생성
8. 파싱 중간에 스크립트 태그가 나오면 자바스크립트 엔진에게 권한을 넘겨 자바스크립트 코드를 파싱하여 AST 코드를 생성 후 실행
9. 그리고 DOM + CSSOM = Render Tree를 생성
10. 여기까지의 과정을 Construction이라고 한다.
11. 그리고 Rendering 엔진은 Render Tree에 있는 Node를 배치(Layout)
12. UI 백엔드는 Render Tree에 있는 Node들을 돌면서 화면에 UI를 그림(Painting)
13. 마지막으로 Render Tree에 있는 Node들을 순서대로 구성(Composition)
14. 여기까지의 과정을 Operation이라고 한다.
15. 마지막으로 웹 사용자에게 결과화면을 출력(Display)

#### Reference

- [웹 브라우저의 동작원리](https://somaz.tistory.com/162)

---

### 2. 마이크로서비스 아키텍처(MSA)란?

마이크로서비스 아키텍처(MSA)는 비즈니스 기능을 구현하는 느슨하게 결합된 서비스(loosely coupled service) 모음으로 애플리케이션을 구성하는 아키텍처 스타일이다.

각 마이크로서비스는 독립적이며 단일 비즈니스 기능을 구현한다.

```bash
느슨하게 결합된 서비스(loosely coupled service)란?

소프트웨어 아키텍처 및 시스템 설계와 같은 서비스 맥락에서 "느슨하게 결합된"은
다른 개별 구성 요소의 정의에 대한 지식이 거의 또는 전혀 없는 구성 요소 또는 서비스를 의미한다.
간단히 말해서 각 구성 요소나 서비스는 직접적인 상호 작용과 의존성을 최소화하면서 서로 독립적으로 작동한다는 의미이다.
```

#### 주요 개념 및 원리

- **모듈성(Modularity)**: 애플리케이션은 더 작고 독립적인 모듈(마이크로서비스)로 나뉜다. 각 마이크로서비스는 특정 기능에 중점을 두고 다른 마이크로서비스와 독립적으로 작동한다.
- **확장성(Scalability)**: 마이크로서비스는 독립적으로 확장될 수 있으므로 애플리케이션의 다양한 구성 요소에 대한 리소스 할당을 더 쉽게 관리할 수 있다.
- **분산형 제어(Decentralized Contro)**: 마이크로서비스는 각 서비스가 자체 데이터와 로직을 관리하는 분산형 데이터 관리 및 제어를 수용한다.
- **기술 스택의 유연성(Flexibility of technology stack)**: 다양한 마이크로서비스는 다양한 기술과 프레임워크를 사용할 수 있으므로 올바른 작업에 적합한 도구를 사용할 수 있다.
- **복원력(Resiliency)**: 하나의 마이크로서비스가 실패하더라도 다른 마이크로서비스는 계속 작동하므로 시스템 전체 오류의 위험이 줄어든다.
- **지속적인 제공 및 배포(Continuous delivery and deployment)**: 마이크로서비스는 민첩한 개발 방식을 지원하므로 전체 애플리케이션에 영향을 주지 않고 개별 서비스를 자주 업데이트하고 신속하게 배포할 수 있다.

---

### 3. DNS(Domain Name Serivce)란?

DNS란 인터넷에서 사용되는 호스트 이름(도메인 이름)을 실제 IP 주소로 변환하는 시스템이다.

#### 동작원리

1. 사용자가 브라우저로 웹 사이트에 접속(e.g., www.example.com)
2. 사용자의 컴퓨터는 도메인 이름을 가지고 로컬 DNS 캐시를 확인 로컬 DNS 캐시에 해당 도메인 이름에 대한 IP 주소가 캐시되어 있다면바로 IP주소를 반환
3. 로컬 DNS 캐시에 해당 도메인 이름에 대한 IP주소가 없다면 DNS 질의 시작
4. 사용자는 먼저 루트 DNS 서버의 IP 주소를 알아내기 위해, 사용자의 컴퓨터에 미리 설정되어 있는 최상위 DNS 서버의 IP 주소를 참조하여 루트 DNS 서버의 IP 주소를 획득
5. 사용자는 루트 DNS 서버에 질의를 보내어, 해당 도메인 이름을 관리하는 TLD(Top Level Domain) DNS 서버의 IP 주소를 얻습니다. (예: .com .org .net 등)
6. 사용자는 TLD DNS 서버에 질의를 보내어, 해당 도메인 이름을 관리하는 Authoritative DNS 서버의 IP 주소를 획득
7. 사용자는 Authoritative DNS 서버에 질의를 보내어, 해당 도메인 이름에 대한 IP 주소를 획득
8. 획득한 IP 주소를 캐시에 저장하고, 이를 브라우저에 반환하여 해당 도메인 이름에 대한 웹 페이지를 표시

#### Reference

- [DNS의 동작원리](https://somaz.tistory.com/172)

---

### 4. 프로그램(Program)과 스레드(Thread)란?

프로그램은 특정 작업을 수행하기 위해 작성된 일련의 지침이다. 일반적으로 디스크나 다른 저장 매체에 저장되는 정적 엔터티이다. 프로그램은 실행될 떄 프로세스가 된다.

프로그램을 실행하면 운영체제는 해당 프로그램을 디스크에서 시스템 메모리로 로드하고 실행을 한다. 프로그램의 실행 중인 인스턴스를 프로세스라고 한다. 각 프로세스에는 자체 메모리 공간와 시스템 리소스가 있다.

그리고 프로그램은 정적이지만 프로세스는 동적이다. 프로그램이 시작될 때 생성되고 실행이 끝나면 종료된다. 동일한 프로그램의 여러 인스턴스를 동시에 실행하여 여러 프로세스를 생성할 수 있다. 각 프로세스는 자체 메모리와 리소스를 가지며 독립적이다.

**요약하자면 프로그램은 코드이고 프로세스는 코드가 실행될 때 발생하는 것이다.**

#### Reference

- [프로세스(Process)와 스레드(Thread)란?](https://somaz.tistory.com/265)

---

### 5. 프로세스(Process)와 스레드(Thread)란?

프로세스와 스레드는 모두 서로 관련되어 있고 매우 유사하므로 둘 사이의 차이점을 이해하는 데 혼란을 야기한다.

프로세스와 스레드는 독립적인 실행 순서이지만 프로세스가 서로 다른 메모리 공간에서 실행되는 반면 동일한 프로세스의 스레드는 공유 메모리 공간에서 실행된다는 점에서 차이가 있다.

#### 프로세스(Process)

프로세스란 자체 메모리 공간이 있는 독립 엔터티로, 애플리케이션에 대한 격리 및 보안을 제공한다.

즉, 프로그램의 실행중인 인스턴스이다. **키워드는 Isolation(격리)이다.**

#### 스레드(Thread)

스레드란 프로세스 내의 더 가벼운 공유 메모리 단위로 작업의 효율적인 병렬 실행을 가능하게 한다.

프로세스의 하위 집합이며 경량 프로세스라고도 한다.

프로세스에는 둘 이상의 스레드가 있을 수 있으며 이러한 스레드는 스케줄러에 의해 독립적으로 관리된다.

**키워드는 Concurrency(동시성)이다.**

<br/>

| Aspect         | 프로세스(Process)                                                                         | 스레드(Thread)                                                                                                |
| -------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| Definition     | 컴퓨터에서 실행되는 프로그램의 인스턴스이다.                                              | 스케줄러가 독립적으로 관리할 수 있는 프로그래밍된 명령의 소규모 시퀀스이다.                                   |
| Memory         | 자체적인 별도의 메모리 공간(힙, 스택 등)이 있다.                                          | 프로세스 내에서 메모리 공간을 공유한다(프로세스의 힙 및 전역 변수에 액세스할 수 있다).                        |
| Creation       | 프로세스 생성은 상위 프로세스의 메모리 복제를 포함하므로 리소스 집약적이고 속도가 느리다. | 스레드를 생성하는 것은 프로세스와 메모리를 공유하므로 리소스 집약도가 낮고 속도도 빠르다.                     |
| Communication  | IPC(프로세스 간 통신)는 별도의 메모리 공간으로 인해 복잡하고 속도가 느리다.               | 스레드 간 통신은 동일한 메모리 공간을 공유하므로 더 쉽고 빠르다.                                              |
| Control        | 운영 체제에 의해 제어된다. 각 프로세스는 독립적으로 작동한다.                             | 이를 소유한 프로세스에 의해 제어된다. 프로세스 내의 모든 스레드는 프로세스 변경으로 인해 영향을 받을 수 있다. |
| Overhead       | 별도의 메모리 및 리소스 관리로 인해 오버헤드가 높아진다.                                  | 스레드가 프로세스의 리소스를 공유하므로 오버헤드가 줄어든다.                                                  |
| Use Case       | 격리된 실행, 안정성 및 보안이 필요한 애플리케이션에 적합하다.                             | 동일한 애플리케이션 내에서 동시 실행이 필요한 작업에 적합하다.                                                |
| Failure Impact | 하나의 프로세스 충돌은 다른 프로세스에 직접적인 영향을 미치지 않는다.                     | 스레드 충돌은 동일한 프로세스 내의 다른 스레드에 영향을 미칠 수 있다.                                         |

#### Reference

- [프로세스(Process)와 스레드(Thread)란?](https://somaz.tistory.com/265)

---

### 6. 스택(Stack)과 큐(Queue)란?

#### 스택(Stack)

스택은 마지막으로 들어간 데이터가 먼저 나오는 후입선출(Last In, First Out; LIFO) 원칙을 따르는 선형 자료구조이다.

##### 주요 작업

- **Push**: 스택의 맨 위에 항목을 추가한다.
- **Pop**: 스택의 맨 위에서 항목을 제거하고 반환한다.
- **Peek** 또는 **Top**: 스택의 맨 위에 있는 요소를 제거하지 않고 반환한다.
- **IsEmpty**: 스택이 비어 있는지 확인한다.

스택은 표현식 평가, 백트래킹 알고리즘, 프로그래밍 언어의 함수 호출 관리 등 다양한 분야에 사용된다.

#### 큐(Queue)

큐는 처음으로 들어간 데이터가 먼저 나오는 선입선출(First In, First Out; FIFO) 원칙을 따르는 선형 자료구조이다. 큐에서는 첫 번째로 추가된 항목이 가장 먼저 제거된다.

##### 주요 작업

- **Enqueue**: 큐의 뒤쪽에 항목을 추가한다.
- **Dequeue**: 큐의 앞쪽에서 항목을 제거하고 반환한다.
- **Front**: 큐의 앞쪽에 있는 항목을 제거하지 않고 반환한다.
- **Rear**: 큐의 뒤쪽에 있는 항목을 반환한다.
- **IsEmpty**: 큐가 비어 있는지 확인한다.

큐는 스케줄링 시스템, 비동기 데이터 처리(IO 버퍼 등), 너비 우선 탐색 알고리즘 등 다양한 시나리오에서 사용된다.

#### 차이점

- **작업 순서**: 스택은 후입선출(LIFO)을 사용하여 마지막에 추가된 요소가 먼저 제거된다. 큐는 선입선출(FIFO)을 사용하여 첫 번째로 추가된 요소가 먼저 제거된다.
- **사용 용도**: 스택은 함수 호출과 같이 재귀적 알고리즘이 구현되는 시나리오에 주로 사용되며, 큐는 인쇄 큐나 작업 스케줄링과 같은 순차적 처리가 필요한 시나리오에 사용된다.

스택과 큐는 컴퓨터 과학에서 기본적인 자료구조로, 각각의 고유한 특성에 따라 다른 용도로 사용된다.

---

### 7. StatefulSet과 Stateless 애플리케이션

#### StatefulSet

StatefulSet은 쿠버네티스에서 상태를 가진(stateful) 애플리케이션을 관리하기 위한 API 오브젝트이다. 각 인스턴스가 고유한 식별자를 유지하며, 영구 스토리지 및 네트워크 아이덴티티를 제공한다.

- **특징**:
  - **Unique Network Identifier(고유한 네트워크 식별자)**: 각 인스턴스는 고유한 이름과 정적 IP를 유지한다.
  - **Persistent Storage(영구 스토리지)**: 각 인스턴스는 자체 Persistent Volume을 유지하여, 데이터의 지속성을 보장한다.
  - **Sequential Deployment and Scaling(순차적 배포 및 스케일링)**: StatefulSet은 순차적 및 예측 가능한 방식으로 인스턴스를 생성하고 스케일한다.
  - **Application State Management(애플리케이션 상태 관리)**: 복제본 간 일관된 상태를 유지하며, 이를 위해 주로 데이터베이스와 같은 상태를 유지하는 애플리케이션에 사용된다.

#### Stateless 애플리케이션

Stateless 애플리케이션은 내부 상태를 유지하지 않고 동작하는 애플리케이션을 말한다. 각 요청은 독립적이며, 이전 요청의 상태에 의존하지 않는다.

- **특징**:
  - **Stateless(무상태)**: 애플리케이션은 내부 상태를 저장하지 않고, 모든 요청을 독립적으로 처리한다.
  - **Horizontal Scalability(수평적 확장성)**: 무상태 애플리케이션은 요청을 처리하는데 필요한 모든 정보를 요청 자체와 함께 전달받기 때문에, 수평적으로 쉽게 확장할 수 있다.
  - **Load Balancing(부하 분산)**: 무상태 애플리케이션은 여러 인스턴스 간에 부하를 균일하게 분산할 수 있어, 고가용성 및 탄력적인 서비스 제공이 가능하다.
  - **Replication and Failure Response(복제와 장애 대응)**: 각 인스턴스가 독립적으로 작동하기 때문에, 장애 발생 시 다른 인스턴스로 요청을 빠르게 전환할 수 있다.

StatefulSet과 Stateless 애플리케이션은 각각 다른 사용 사례와 요구 사항을 충족시키며, 쿠버네티스 환경에서 중요한 역할을 한다.

---

### 8. GitOps란?

GitOps는 2017년에 위브웍스(Weaveworks Inc.)에서 처음 사용한 용어로 프로젝트에 DevOps의 실천 방법 중 하나이다. 클라우드 네이티브 애플리케이션을 대상으로 한 지속적 배포(Continuous Deployment)에 초점을 두고 있다. 단어로 알 수 있듯이 애플리케이션의 배포와 운영에 관련된 모든 요소들을 코드화하여 Git에서 관리(Operation) 한다는 것을 뜻한다.

#### GitOps 핵심 개념

- **Git as the Source of Truth**
  - 인프라 및 애플리케이션(예: Kubernetes 매니페스트, Terraform 코드 등)에 대한 모든 정의는 Git 저장소에 저장된다.
- **Declarative System State**
  - 시스템에 특정 상태에 도달하는 방법을 알려주는 대신(명령형) 상태가 무엇이어야 하는지 선언하고(선언적), 시스템은 이를 그렇게 만드는 책임을 진다.
- **Rollbacks and History**
  - 변경 사항을 Git 저장소에 푸시하면 자동화된 프로세스를 통해 선언된 상태가 실제 시스템에 적용된다. 3개의 서버가 필요하다고 선언했는데 2개만 있으면 자동화된 프로세스가 시작되어 다른 서버를 생성한다.
- **Merge Requests for Change Management**
  - 인프라 또는 애플리케이션에 대한 변경은 병합 요청을 통해 이루어집니다. 코드와 마찬가지로 인프라 변경 사항이 제안되고 검토되며 승인되면 병합된다. 즉, 어떤 변경이 이루어졌는지, 누가, 왜 변경되었는지에 대한 기록이 있다는 의미이다.
- **Continuous Monitoring and Reconciliation**
  - 라이브 시스템의 현재 상태를 지속적으로 모니터링하고 Git에 선언된 원하는 상태와 비교한다. 차이가 있는 경우 Git의 선언과 일치하도록 시스템이 자동으로 수정한다.

#### GitOps Workflow 예시

1. 개발자가 Git 리포지토리에서 애플리케이션 구성을 변경한다.
2. 해당 변경 사항에 대한 `pull request(pr)`을 제출한다.
3. 팀은 변경 사항을 검토하고 테스트를 실행한 후 이를 메인 브랜치에 병합한다.
4. CD(지속적 배포) 도구는 리포지토리의 변경 사항을 감지하고 해당 변경 사항을 환경에 자동으로 적용한다.
5. 환경의 운영자는 라이브 상태가 Git에 선언된 상태와 일치하는지 지속적으로 확인한다. 그렇지 않은 경우 필요한 변경 사항을 적용한다.

#### Reference

- [ArgoCD란?](https://somaz.tistory.com/226)

---

### 9. 클린 아키텍처(Clean Architecture)란?

**Clean Architecture**는 소프트웨어 설계의 한 방법으로, 소프트웨어 시스템을 유연하고, 유지보수가 용이하며, 테스트하기 쉬운 구조로 만들기 위한 가이드라인을 제공한다. 이 아키텍처는 로버트 C. 마틴(Robert C. Martin, "Uncle Bob"으로도 알려짐)에 의해 소개되었으며, 다양한 소프트웨어 설계 원칙들을 통합하여 애플리케이션의 비즈니스 로직과 인터페이스, 데이터베이스, 외부 에이전시 등의 세부 사항을 분리한다.

#### 주요원칙

- **독립성 (Independence)**: 시스템의 핵심 비즈니스 로직은 사용자 인터페이스, 데이터베이스, 외부 에이전시, 프레임워크 등과 같은 세부 사항으로부터 독립적이어야 한다. 이를 통해 시스템은 UI나 데이터베이스 교체와 같은 변경 사항에 유연하게 대응할 수 있다.
- **가독성과 재사용성 (Readability and Reusability)**: 코드는 명확하고, 이해하기 쉬워야 하며, 다른 맥락에서도 재사용될 수 있어야 한다.
- **테스트 용이성 (Ease of testing)**: 비즈니스 로직은 외부 요소와의 의존성 없이 독립적으로 테스트 가능해야 한다.

#### 레이어

Clean Architecture는 일반적으로 네 개의 주요 레이어로 구성된다.

- **Entities (엔티티)**: 애플리케이션의 핵심 비즈니스 규칙을 포함한다. 애플리케이션의 비즈니스 객체나 데이터 구조로, 가장 내부적인 레이어에 위치한다.
- **Use Cases (유즈 케이스)**: 애플리케이션의 비즈니스 로직이 구현된다. 엔티티를 사용하여 사용자의 요구 사항을 충족하는 과정을 정의한다.
- **Interface Adapters (인터페이스 어댑터)**: 유즈 케이스와 애플리케이션의 외부(예: 웹, 데이터베이스) 사이의 변환을 담당합니다. 컨트롤러, 프레젠터, 게이트웨이 등이 여기에 속한다.
- **Frameworks and Drivers (프레임워크와 드라이버)**: 데이터베이스, 웹 프레임워크, 디바이스 드라이버 등과 같은 외부 인터페이스와 도구들이다. 이 레이어는 가장 외부적인 레이어로, 애플리케이션의 세부 사항을 구현한다.

마지막으로 Clean Architecture는 비즈니스 로직과 애플리케이션의 다른 측면 사이의 엄격한 분리를 통해, 변경에 대한 유연성, 시스템의 테스트 용이성, 비즈니스 로직의 중앙 집중화를 추구한다. 이 아키텍처 접근 방식은 장기적인 유지 보수와 시스템의 확장성을 향상시키는 데 도움이 된다.

---

### 10. Cloud-Native Application Communication and Data Access Patterns

### AWS

컨테이너 오케스트레이션을 위한 Amazon Elastic Kubernetes Service(EKS), DNS를 위한 Route 53, 요청 라우팅을 위한 Elastic Load Balancing(ELB), 보안 내부 통신을 위한 AWS PrivateLink 또는 VPC 피어링과 같은 서비스를 사용하여 AWS에서 3-tier 아키텍처를 구현할 수 있다.

#### 1. Presentation Layer

- **AWS 서비스**: Amazon Route 53
- **프로세스**:
  - 사용자는 웹 브라우저나 앱을 통해 애플리케이션의 도메인 이름(예: www.example.com)으로 요청을 보낸다.
  - Amazon Route 53은 요청된 도메인 이름을 AWS Elastic Load Balancer(ELB)의 IP 주소 또는 Amazon EKS의 Ingress 리소스로 확인한다.

#### 2. Application Layer

- **AWS 서비스**: Amazon Elastic Kubernetes Service(EKS), Elastic Load Balancing(ELB)
- **프로세스**:
  - EKS 내의 ELB 또는 Ingress 컨트롤러는 외부 요청을 EKS 클러스터 내의 적절한 파드로 라우팅한다.
  - 애플리케이션 서버를 실행하는 이러한 파드는 도메인 요청을 처리하고 데이터베이스 또는 Redis와 같은 데이터 스토리지에 액세스하여 비즈니스 로직을 처리할 수 있다.

#### 3. Data Layer

- **AWS 서비스**: 데이터베이스용 Amazon RDS/Aurora, Redis용 Amazon ElastiCache, AWS PrivateLink 또는 VPC 피어링
- **프로세스**:
  - 데이터베이스 및 Redis 인스턴스는 각각 Amazon RDS/Aurora 및 Amazon ElastiCache와 같은 AWS 서비스 내에서 호스팅되며 프라이빗 네트워크 내에 배치된다.
  - 이러한 서비스는 AWS PrivateLink 또는 VPC 피어링을 사용하여 클라우드 내에서 안전하게 액세스할 수 있으므로 인터넷에서 직접 액세스할 수 없다.
  - EKS 클러스터 내의 애플리케이션 서버는 구성된 VPC 네트워킹을 통해 이러한 데이터베이스와 Redis 인스턴스에 안전하게 액세스하여 데이터 처리 및 관리를 지원한다.

#### Summary

- **외부 요청 처리**: 사용자 → DNS(Amazon Route 53) → AWS ELB → EKS Pod(애플리케이션 서버)
- **내부 데이터 액세스**: EKS Pod(애플리케이션 서버) → VPC 네트워킹 → AWS PrivateLink 또는 VPC 피어링을 통한 DB/Redis 액세스(Amazon RDS/Aurora, Amazon ElastiCache)

### GCP

Google Kubernetes Engine(GKE)에서 호스팅되는 애플리케이션에 대한 외부 도메인 호출 및 내부 데이터베이스(DB) 및 Redis 접근에 대한 3-tier 아키텍처 관점에서의 통신 과정은 다음과 같다.

#### 1. Presentation Layer

- 사용자가 웹 브라우저나 앱을 통해 애플리케이션의 도메인 이름으로 요청을 보낸다 (예: www.example.com).
- DNS 조회를 통해 요청된 도메인 이름이 GKE의 Ingress 리소스나 Load Balancer의 IP 주소로 해석됩니다. GCP의 Cloud DNS 같은 서비스가 이 역할을 수행할 수 있다.

#### 2. Application Layer

- Ingress 컨트롤러나 Load Balancer는 외부 요청을 GKE 클러스터 내의 적절한 파드로 라우팅한다. 파드들은 애플리케이션 서버를 실행하고 있으며, 도메인 요청에 대한 처리를 담당한다.
- 애플리케이션 서버는 비즈니스 로직 처리를 위해 필요에 따라 데이터베이스(DB)나 Redis와 같은 데이터 저장소에 접근한다.

#### 3. Data Layer

- 데이터베이스(DB)와 Redis 인스턴스는 GCP의 Private Access를 통해 프라이빗 네트워크상에 배치된다. 이는 인터넷으로부터 직접 접근할 수 없음을 의미하며, 클라우드 내부 또는 VPN을 통한 연결을 통해서만 접근이 가능하다.
- GKE 클러스터 내의 애플리케이션 서버는 VPC 내에서 구성된 Private Access를 통해 DB와 Redis에 안전하게 접근한다. 이를 통해 데이터를 조회하거나 변경하는 요청을 처리할 수 있다.

#### Summary

- **외부 요청 처리**: 사용자 → DNS → GCP Load Balancer/Ingress → GKE Pod(애플리케이션 서버)
- **내부 데이터 접근**: GKE Pod(애플리케이션 서버) → VPC 네트워킹 → Private Access를 통한 DB/Redis 접근

---

### 11. 동기(Synchronous Processing) 및 비동기 처리(Asynchronous Processing)란?

- 동기 처리에서는 작업이 한 번에 하나씩 순서대로 완료된다. 이는 다음 작업을 시작하기 전에 작업을 완료해야 함을 의미한다. 이러한 유형의 처리는 간단하고 이해하기 쉽다.
- 비동기 처리를 통해 작업을 기본 프로그램 흐름과 독립적으로 실행할 수 있으므로 백그라운드에서 작업을 처리할 수 있다. 이러한 유형의 처리는 웹 서버나 사용자 인터페이스를 갖춘 애플리케이션과 같이 작업에 상당한 시간이 걸릴 수 있는 환경에 필수적이다.

#### 동기 처리 특징

- **차단(Blocking)**: 각 작업은 다음 작업이 시작되기 전에 완료되어야 하며, 실행중인 작업이 완료될 때까지 후속 작업을 차단한다.
- **선형 실행(Linear Execution)**: 작업은 코드에 나타나는 정확한 순서대로 실행된다.
- **단순성(Simplicity)**: 작업 실행의 순차적 특성으로 인해 프로그래밍 및 디버깅이 더 쉽다.
- **사용 예(Usage Examples)**: 파일 읽기 또는 쓰기, 데이터베이스 트랜잭션 또는 후속 작업이 이전 작업의 결과에 의존하는 모든 작업에 사용한다.

#### 비동기 처리 특징

- **비차단(Non-blocking)**: 작업은 독립적으로 시작하고 완료할 수 있으며, 프로그램은 작업을 시작하고 완료될 때까지 기다리지 않고 계속 진행할 수 있다.
- **동시 실행(Concurrent Execution)**: 여러 작업을 병렬로 처리할 수 있어 애플리케이션의 효율성과 응답성이 향상된다.
- **복잡성(Complexity)**: 경쟁 조건 및 교착 상태와 같은 잠재적인 문제로 인해 프로그래밍 및 디버그가 더 어렵다.
- **사용 예(Usage Examples)**: API 요청, 파일 업로드 또는 사용자 인터페이스를 정지하거나 다른 계산을 지연시키고 싶지 않은 장기 실행 I/O 작업에 사용한다.

#### Summary

동기 처리와 비동기 처리 사이의 선택은 애플리케이션 요구 사항에 따라 달라진다.

- **동기**: 작업을 특정 순서로 완료해야 하거나 다음 작업에 각 작업의 출력이 필요할 때 사용
- **비동기**: 특히 작업이 독립적이거나 병렬로 수행될 수 있는 경우 애플리케이션의 처리량과 응답성을 향상시키는 데 사용

---

### 12. 3tier 아키텍처란?

전통적인 3tier 아키텍처는 애플리케이션을 프레젠테이션, 애플리케이션, 데이터라는 세 가지 논리적 및 물리적 컴퓨팅 계층으로 구성하는 널리 사용되는 소프트웨어 애플리케이션 아키텍처이다. 그러나 현대 웹 개발에서는 특히 클라우드 기술과 서비스의 출현으로 인해 웹과 애플리케이션 서버(WAS)의 구분이 모호해졌다.

#### 전통적인 3tier 아키텍처

- **프레젠테이션 계층(Client Tier)**: 애플리케이션의 사용자 인터페이스이다. 이는 사용자에게 애플리케이션을 제시하고, 모든 데이터에 대해 애플리케이션 계층과 통신하며, 결과를 사용자에게 다시 제공한다.
- **애플리케이션 계층(Business Logic/Logic Tier)**: 이 계층은 애플리케이션을 조정하고, 명령을 처리하고, 논리적인 결정과 평가를 내리고, 계산을 수행한다. 또한 두 개의 주변 레이어 간에 데이터를 이동하고 처리한다.
- **데이터 계층(Data Tier)**: 여기에는 데이터베이스 및 데이터 저장 시스템이 포함된다. 데이터 계층은 데이터의 물리적 저장 및 검색을 관리한다.

#### 웹 개발의 최신 접근 방식

현대 웹 개발에서는 특히 클라우드 기술과 서비스의 출현으로 인해 웹과 애플리케이션 서버(WAS)의 구분이 모호해졌다.

- **웹 서버(Web)**: 전통적으로 HTTP 요청을 처리하고, 정적 콘텐츠를 제공하고, 동적 콘텐츠 요청을 애플리케이션 서버에 전달했습다.
- **애플리케이션 서버(WAS)**: 사용자 인터페이스와 데이터베이스 간의 비즈니스 로직 및 상호 작용을 처리한다. 애플리케이션을 실행하고 데이터베이스에서 반환된 데이터를 처리했다.
  > 요즘에는 많은 웹 프레임워크의 정적 컨텐츠와 동적 컨텐츠 모두 처리할 수 있는 내장 서버(예: Spring Boot의 Tomcat)가 함께 제공되므로 많은 시나리오에서 별도의 웹 서버와 애플리케이션 서버가 필요하지 않다.

#### 전통적인 3tier 아키텍처와 현대의 웹 개발방식과의 비교

| Aspect                      | Traditional 3-Tier Architecture간              | Modern Web Development 중                                                    |
| --------------------------- | ---------------------------------------------- | ---------------------------------------------------------------------------- |
| Separation                  | Clear separation of concer공s                  | Blurred lines, often combined layers                                         |
| Web Server (WS)             | 정적 컨텐츠만 제공                             | 정적 및 동적 컨텐츠 제공                                                     |
| Application Server (WAS)    | 비즈니스 로직을 독점적으로 처리                | 애플리케이션에 내장형으로 모든 비즈니스 로직을 처리                          |
| Scalability                 | 더 많은 중간 계층을 추가하여 확장성 향상       | 마이크로서비스, 컨테이너 노드 같은 서비스 컴포넌트로 확장 가능               |
| Deployment Complexity       | 복도의 유지 관리 및 업데이트 필요성 발달       | 도입 서비스 및 클라우드 제공형식을 이해 간소화 동시에 라이프사이클 이해 필요 |
| Development and Maintenance | 상호운용성을 위해 다양 부품연동                | 내부적으로 종속성을 관리하는 프레임워크 및 서비스 다수화 도입                |
| Example Technologies        | Apache 웹 서버, Oracle WebLogic, IBM WebSphere | Node.js, Spring Boot, Django(Tomcat 포트 Gunicorn과 같은 내장 서버 사용)     |

---
